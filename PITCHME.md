### EmberJS vs React
<br>
<span style="color:gray">comparison of client side JS frameworks</span>
<br>

---

### Client Side Frameworks
<span style="color:gray">Common Flow</span>
<br>

![FLOW](https://www.smashingmagazine.com/wp-content/uploads/2016/01/04-client-side-rendering-opt.png)

---

### Basics
Feature | EmberJS | React
---------- | ------------ | -------------
Inception Year | 2011 | 2013
Current Version | 2.12 | 15.5.0
Type of framework | Fully fledged MVC | View layer only
"Rendering Engine" | Glimmer | Virtual DOM Diffing
"Templating Engine" | Handlebars | JSX

---

### View Layer Concepts
#### Binding
EmberJS | React
---------- | ------------ 
two-way bindings possible, used for e.g. `<input>` elements | one-way bindings only
through the concept of mixins and dependency injection (service) this does not necessarily lead to complex top level components | leads to complex top level components

---

### View Layer Concepts
#### Props and State
EmberJS | React
---------- | ------------ 
Properties are passed from the parent  | Props are passed from the parent component to the child component, immutable
Must use this.set(‘obj’, obj) and this.get(‘obj’) | Must use this.setState({obj}) and this.state.obj
Actions are real events and bubble up | “Actions” must be passed in as props and are plain callbacks

---

### View Layer Examples
#### Conditionals - HBS
```hbs
{{#if person}}
  Welcome back, {{person.name}}
{{else}}
  Login
{{/if}}
```

---

### View Layer Examples
#### Conditionals - JSX - recommended way
```js
function Greeting(props){
    if (props.person){
        return (
            <div>
                Welcome back, {props.person.name}
            </div>
        )
    }
    return (
        <div>
            Login
        </div>
    )
}
ReactDOM.render(
    <Greeting person={jsonResponse.person}/>
    document.getElementById('root')
)
```

---

### View Layer Examples
#### Conditionals - JSX - inline way
```js
ReactDOM.render(
    <div>
        {this.props.person ? (
            <div>Welcome back, {this.props.person.name}</div>
        ) : (
            <div>Login</div>
        )}
    </div>,
    document.getElementById('root')
)
```

---

### View Layer Examples
#### Iterating - HBS
```hbs
<ul>
    {{#each persons as |person|}}
        <li>{{person.name}}</li>
    {{/each}}
</ul>
```

---

### View Layer Examples
#### Iterating - JSX
```js
function ListItem(props){
    return <li>{props.name}</li>
}
return (
    <ul>
    {persons.map((person)=>
        <ListItem key="{person.id}" name={person.name}/>
    )}
    </ul>
)
```

---

### View Layer Examples
#### Iterating - JSX - recommended way
```js
function ListItems(props){
    const persons = props.persons;
    const listItems = persons.map((person) => {
        return <li>{person.name}</li>
    });
    return (
        <ul>{listItems}</ul>
    )
}
```

---

### View Layer Examples
#### Iterating - JSX - inline way
```js
function ListItem(props){
    return <li>{props.name}</li>
}
return (
    <ul>
    {persons.map((person)=>
        <ListItem key="{person.id}" name={person.name}/>
    )}
    </ul>
)
```

---

### React Templates
#### Conditionals
```js
<div>
    <p rt-if="this.props.person">Welcome back, {person.name}</p>
    <ul>
        <li rt-repeat="person in this.props.persons">{person.name}</li>
    </ul>
</div>
```
- no `else`, `switch`, `while` etc.
- must be precompiled

---

### React Data Flow
#### Lifting state up
- uni-directional flow isn’t very scalable
- if you want to share state between separate components, you have to 1) find the nearest common ancestor component 2) store the shared state on it, and 3)feed callbacks through all intermediate components to the two components
- Your parent components will continue to bloat (fat interface problem)
- Intermediate components now have added responsibility of forwarding through callbacks they don’t really care about

---

### React Data Flow
#### Flux/Redux
Feature | Presentational Components | Container Components
--- | --- | ---
Purpose | How things look | How things work (fetching data, state updates)
Aware of Redux | No | Yes
read data | read from props | subscribes to redux state
write data | invoke callbacks from props | dispatch redux actions
are written | by hand | usually generated by react redux

---

### React Data Flow
#### Reducers, Middleware, Store enhancers

TODO

--- 

### Routing
#### EmberJS

- builtin
- easy and flexible
```js
Router.map(function() {
  this.route('index', { path: '/' });
  this.route('posts', function() {
    this.route('new');
  });
  this.route('post', { path: '/post/:post_id' });
});
```

--- 

### Routing
#### EmberJS

- not builtin
- most common library is React-Router
```js
const Post = ({match}) => (
    <div>Post ID: {match.params.id}<div>
)
ReactDOM.render(
    <Route exact path="/" component={Home}/>
    <Route exact path="/posts" component={Posts}/>
    <Route exact path="/posts/new" component={NewPost}/>
    <Route path="/post/:id" component={Post}/>
)
```

---

### React Drawbacks
- Flow control (if blocks, loops), or anything involving lambdas, are awkward
- Often they need to be kept visually separate from the rest of your render code
- Component.render must return a single element (with any number of children)
- Tempting to want to return something like `<div></div><div></div>`, but that’s like returning div(),div() (and React doesn’t support returning arrays)
- Items in lists must have a key (in order for the rendering to be performant)
- requires lots of extensions to be useful, react-router, react-redux...
